# Cursor Rules: Security, KISS, and 12-Factor Development

## Core Principles

### KISS (Keep It Simple, Stupid)
- Prefer simple, readable solutions over clever optimizations
- Avoid unnecessary abstractions and complexity
- Write code that a junior developer can understand
- One function should do one thing well
- Use standard libraries and tools over custom implementations

### 12-Factor App Development
I. **Codebase**: One codebase tracked in revision control, many deploys
II. **Dependencies**: Explicitly declare and isolate dependencies
III. **Config**: Store config in the environment (never hardcode secrets)
IV. **Backing Services**: Treat backing services as attached resources
V. **Build, Release, Run**: Strictly separate build and run stages
VI. **Processes**: Execute the app as one or more stateless processes
VII. **Port Binding**: Export services via port binding
VIII. **Concurrency**: Scale out via the process model
IX. **Disposability**: Maximize robustness with fast startup and graceful shutdown
X. **Dev/Prod Parity**: Keep development, staging, and production as similar as possible
XI. **Logs**: Treat logs as event streams (stdout/stderr)
XII. **Admin Processes**: Run admin/management tasks as one-off processes

## Security Rules

### Input Validation & Sanitization
- Always validate and sanitize all user inputs, environment variables, and CLI arguments
- Use whitelist validation over blacklist where possible
- Reject invalid input early; fail fast and fail securely
- Never trust user input, file paths, or network data
- Validate file paths to prevent directory traversal attacks
- Use parameterized queries/prepared statements for any database operations
- Escape shell arguments properly; use arrays for command arguments in bash

### Authentication & Authorization
- Never hardcode credentials, tokens, or API keys in code
- Use environment variables or secure secret management systems
- Implement principle of least privilege - grant minimum necessary permissions
- Verify authentication before processing any request
- Use secure session management with proper expiration
- Never log sensitive authentication data

### Secure Coding Practices
- Use `set -euo pipefail` in all bash scripts
- Always quote variables in bash to prevent word splitting and glob expansion
- Use `readonly` for constants that should not be modified
- Validate file permissions before reading/writing sensitive files
- Use secure temporary file creation (`mktemp` with proper permissions)
- Clean up temporary files and sensitive data after use
- Never execute user-provided code or commands without validation
- Use `exec` with arrays for command execution to prevent injection

### Error Handling
- Never expose internal system details in error messages
- Log errors securely without exposing sensitive information
- Fail securely - default to deny/restrict on errors
- Use structured logging with appropriate log levels
- Never log passwords, tokens, or other secrets
- Handle errors gracefully without revealing system internals

### Network Security
- Use TLS/SSL for all network communications
- Validate SSL certificates; never disable certificate verification
- Use secure protocols (HTTPS, WSS, SSH) over insecure ones
- Implement proper timeout and retry logic
- Validate network input before processing
- Use connection pooling and rate limiting where appropriate

### File System Security
- Validate file paths before operations
- Use absolute paths when possible, or validate relative paths
- Set appropriate file permissions (avoid world-writable files)
- Never create files in world-writable directories without validation
- Use secure file creation patterns (`O_CREAT | O_EXCL` or `mktemp`)
- Clean up temporary files securely

### Process Security
- Run processes with minimum required privileges
- Use non-root users when possible
- Validate process inputs and outputs
- Implement resource limits (CPU, memory, file descriptors)
- Use secure process communication mechanisms
- Avoid shell command execution when library functions exist

### Container Security (Podman/Buildah)
- Always use non-root users in containers when possible
- Scan container images for vulnerabilities
- Use minimal base images (distroless, alpine)
- Never embed secrets in container images
- Use multi-stage builds to reduce image size
- Set appropriate security contexts and capabilities
- Use read-only root filesystems where possible
- Implement health checks for containers

## Code Quality Rules

### Bash Scripting
- Always use `set -euo pipefail` at the start
- Quote all variables: `"$VAR"` not `$VAR`
- Use arrays for command arguments: `cmd "${args[@]}"`
- Validate required environment variables before use
- Use `readonly` for constants
- Prefer functions over inline code for reusability
- Use local variables in functions: `local var="value"`
- Validate file existence before operations: `[[ -f "$file" ]]`
- Use `[[ ]]` for conditionals, not `[ ]`
- Always check command exit codes explicitly

### Python (if used)
- Use virtual environments (venv) for all Python projects
- Explicitly declare all dependencies in requirements.txt
- Use type hints for function signatures
- Validate inputs with proper exception handling
- Use context managers for resource management
- Follow PEP 8 style guidelines
- Use `argparse` for CLI argument parsing
- Never use `eval()` or `exec()` with user input

### Configuration Management
- Store configuration in environment variables, not code
- Use `.env` files for local development only (never commit secrets)
- Provide sensible defaults with clear documentation
- Validate configuration at startup
- Use configuration files for non-sensitive defaults
- Document all configuration options

### Dependency Management
- Pin dependency versions explicitly
- Regularly update dependencies for security patches
- Use dependency scanning tools
- Document why each dependency is needed
- Prefer well-maintained, widely-used libraries
- Isolate dependencies (use venv, containers, etc.)

### Logging
- Use structured logging (JSON format preferred)
- Include context (timestamp, request ID, user) in logs
- Use appropriate log levels (DEBUG, INFO, WARN, ERROR)
- Never log sensitive data (passwords, tokens, PII)
- Log to stdout/stderr for 12-factor compliance
- Use log aggregation tools in production

### Testing
- Write tests for all critical functionality
- Test error conditions and edge cases
- Test security boundaries and input validation
- Use test fixtures, not production data
- Run tests in isolated environments
- Test with minimal privileges

## Project-Specific Rules

### Shell Scripts
- All scripts must start with `#!/bin/bash` and `set -euo pipefail`
- Use `SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"` for script directory
- Validate all required environment variables before use
- Use functions for reusable logic
- Document all functions with comments
- Exit with appropriate exit codes (0 = success, non-zero = failure)

### Container Images
- Always use Podman/Buildah, never Docker
- Use Containerfile (not Dockerfile)
- Build with `buildah bud` or `podman build`
- Run with `podman run` (not docker)
- Use minimal base images
- Never run as root unless absolutely necessary

### OpenShift/Kubernetes
- Use `oc` CLI for OpenShift operations
- Validate cluster connectivity before operations
- Use proper RBAC and service accounts
- Never hardcode cluster credentials
- Use ConfigMaps and Secrets appropriately
- Implement proper resource limits

### Open Source Project Guidelines
- This is an open source project - never include usernames, GitHub usernames, or personal identifiers
- Use generic placeholders in documentation (e.g., `<your-username>`, `example.com`, `worker1.example.com`)
- Never hardcode repository URLs with specific usernames or organizations
- Keep all examples generic and reusable by anyone
- Use placeholder formats like `https://github.com/<your-username>/repo-name.git` instead of real usernames

## Code Review Checklist

Before submitting code, ensure:
- [ ] All inputs are validated and sanitized
- [ ] No secrets or credentials are hardcoded
- [ ] Error handling is implemented securely
- [ ] Code follows KISS principles (simple and readable)
- [ ] Configuration comes from environment variables
- [ ] Dependencies are explicitly declared
- [ ] Logging doesn't expose sensitive information
- [ ] File operations are secure (path validation, permissions)
- [ ] Network operations use secure protocols
- [ ] Scripts use `set -euo pipefail` and proper quoting
- [ ] Functions are small and focused (single responsibility)
- [ ] Code is tested and documented

## Anti-Patterns to Avoid

- ❌ Hardcoding secrets, credentials, or API keys
- ❌ Using `eval` or executing unvalidated user input
- ❌ Exposing internal errors to users
- ❌ Logging sensitive information
- ❌ Running processes as root unnecessarily
- ❌ Using insecure protocols (HTTP, FTP, telnet)
- ❌ Ignoring command exit codes
- ❌ Unquoted variables in bash
- ❌ Complex nested conditionals (violates KISS)
- ❌ Premature optimization
- ❌ Mixing configuration with code
- ❌ Committing `.env` files with secrets
- ❌ Using Docker instead of Podman/Buildah
- ❌ Including usernames, GitHub usernames, or personal identifiers in code or documentation
- ❌ Hardcoding repository URLs with specific usernames

## When in Doubt

1. **Security**: If unsure, choose the more secure option
2. **Simplicity**: If two solutions work, choose the simpler one
3. **Explicitness**: Make dependencies and configuration explicit
4. **Validation**: Validate early, validate often
5. **Documentation**: Document why, not just what

